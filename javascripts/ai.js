AI = (function() {

  /** @const @type {int} */
  var AI_INTERVAL = DEBUG ? 10 : 750;

  /** @const @type {boolean} */
  var MOVE_CURSOR = true;

  /** @const @type {boolean} */
  var USE_TASK_QUEUE = true;

  // AI tasks that can be assigned to individual units.
  var TASK_BUILD    = { priority: 3, name: 'BUILD',   targetType: UnitType };
  var TASK_KILL     = { priority: 5, name: 'KILL',    targetType: Unit };
  var TASK_HEAL     = { priority: 4, name: 'HEAL',    targetType: Terrain };
  var TASK_CAPTURE  = { priority: 4, name: 'CAPTURE', targetType: Terrain };
  var TASK_RAISE    = { priority: 3, name: 'RAISE',   targetType: Grave };

  // Modes identifying each of the possible AI thinking phases.
  var MODE_ORGANIZE_UNITS     = DEBUG ? "ORGANIZE_UNITS"     : 1;
  var MODE_PREPROCESS_UNITS   = DEBUG ? "PREPROCESS_UNITS"   : 2;
  var MODE_EVALUATE_STRENGTHS = DEBUG ? "EVALUATE_STRENGTHS" : 3;
  var MODE_EVALUATE_TERRAIN   = DEBUG ? "EVALUATE_TERRAIN"   : 4;
  var MODE_EVALUATE_UNITS     = DEBUG ? "EVALUATE_UNITS"     : 5;
  var MODE_EVALUATE_GRAVES    = DEBUG ? "EVALUATE_GRAVES"    : 6;
  var MODE_SORT_TASKS         = DEBUG ? "SORT_TASKS"         : 7;
  var MODE_PROCESS_TASKS      = DEBUG ? "PROCESS_TASKS"      : 8;

  // An array of all of the AI thinking modes in order.
  var ALL_MODES = [
      MODE_ORGANIZE_UNITS, MODE_PREPROCESS_UNITS, MODE_EVALUATE_STRENGTHS,
      MODE_EVALUATE_TERRAIN, MODE_EVALUATE_UNITS, MODE_EVALUATE_GRAVES,
      MODE_SORT_TASKS, MODE_PROCESS_TASKS
  ];

  // Pool of reusable task objects previously generated.
  var taskPool = Pool.create(true, DEBUG ? "task" : null);

  // The queue of tasks generated by the AI during a given turn.  May
  // be repeatedly regenerated during an AI's turn based on changes
  // in play.
  var taskQueue = USE_TASK_QUEUE ? [] : null;

  // The currently active AI.
  var currentAi  = null;

  // The currently active AI's personality biases.
  var currentBias = null;

  // The current mode used during think() to process the AI without
  // locking the rendering thread.
  var currentMode = null;

  /** @type {int} Transient index used during thinking. */
  var currentIndex = 0;

  // The currently assigned task or the highest priority task during
  // task resolution.
  var currentTask = null;

  // Working variable used to hold targeting state while resolving
  // the current task.
  var nextTarget = null;

  /** @type {int} The number of milliseconds since the AI last
   * processed.  This is incremented during step() when
   * currentAi is not null. */
  var totalDelta = 0;

  // Lists, for convenience, of friendly and enemy units, respectively, populated
  // during AI preprocessing.
  var friendlyUnits  = [ ];
  var readyUnits     = [ ];
  var enemyUnits     = [ ];
  var tacticalNodes  = [ ];

  // Function to sort tasks by priority, descending.
  var taskSorter = function(t1, t2) {
    return t2.priority - t1.priority;
  };

  // Function to sort tasks by priority, descending.
  var nodeSorter = function(t1, t2) {
    return t2.aiWeight - t1.aiWeight;
  };

  // Helper function which clears the next target.
  var clearNextTarget = function() {
    nextTarget = null;
  };

  function allocateTask(type, unit, modifier, x, y, target, noDistancePenalty) {

    var t = taskPool.allocate();

    t.modifier = modifier;
    t.priority = (type.priority + modifier);
    t.target   = target;
    t.type     = type;
    t.unit     = unit;
    t.x        = x;
    t.y        = y;

    // If a unit has been provided then we need to scale the priority
    // based on the unit's distance to the target.
    if (unit && !noDistancePenalty) {

      var distance = Pathfinder.manhattanDistance(unit.x, unit.y, x, y);
      if (distance < 1) {
        distance = 1;
      }

      t.priority /= distance;

    }

    if (currentBias.randomness > 0) {

      var randomness = t.priority * currentBias.randomness;

      randomness = Math.random() * randomness;

      if (coinToss()) {
        randomness = 0 - randomness;
      }

      t.priority += randomness;

    }

    if (USE_TASK_QUEUE) {
      taskQueue.push(t);

    } else {

      // If there is no primary task or if the priority of the
      // newly allocated task choose it as the new current task.
      if (currentTask === null || t.priority > currentTask.priority || (t.priority === currentTask.priority && coinToss())) {
        currentTask = t;

      } else {

        // If the task queue is not being used, no sense in keeping
        // the task around - deallocate immediately.
        taskPool.deallocate(t);

      }

    }

    return t;
  }

  function deallocateTask(t) {

    // Clear references to objects.
    t.unit   = null;
    t.target = null;

    if (USE_TASK_QUEUE) {
      taskQueue.remove(t);
    }

    taskPool.deallocate(t);

  }

  function taskToString(t) {

    var action;

    // Get a handle on the type of the task - e.g. TASK_BUILD.
    var taskType = t.type;

    // Get a local handle on the target type for this task.  This
    // points to an overall class (e.g. Unit) which is expected to
    // have a toString() method.
    var targetType = taskType.targetType;

    // Get the name of the target as a readable string.
    var target = targetType.toString(t.target);

    var s = "Task#" + t.id + " " + taskType.name + " " + target + " (" + t.x + "," + t.y + ") [" + t.priority.toFixed(3) + ", +" + t.modifier.toFixed(1) + "]";

    if (t.unit) {
      s += " by " + Unit.toString(t.unit) + " (" + t.unit.x + "," + t.unit.y +")";
    }

    return s;
  }

  function evaluatePosition(unit, x, y) {

    var originalX = unit.x;
    var originalY = unit.y;

    // Temporarily move the unit to it's possible destination so
    // we can determine what the unit can attack and from which
    // enemies it will be threatened from this point.
    unit.x = x;
    unit.y = y;

    var terrain        = Map.terrainAt(x, y);
    var positionWeight = terrain.defense * currentBias.defenseMultiplier;

    var vsUnit;
    var vsUnitType;
    var ds;

    var totalEnemyUnits = enemyUnits.length;
    for (var i = 0; i < totalEnemyUnits; ++i) {
      vsUnit = enemyUnits[i];

      if (Unit.isUnitInAttackRange(unit, vsUnit)) {
        positionWeight += unit.aiRelativeWeight;
      }

      if (Unit.isUnitInAttackRange(vsUnit, unit)) {
        positionWeight -= vsUnit.aiRelativeWeight;
      }

    }

    var unitType = unit.type;

    // True if the unit being considered provides a range bonus
    // such as blessing or berzerk strength.
    var myBonus = unitType.bless > 0 || unitType.berzerk > 0;

    var totalFriendlyUnits = friendlyUnits.length;
    for (i = 0; i < totalFriendlyUnits; ++i) {
      vsUnit = friendlyUnits[i];
      if (vsUnit !== unit) {

        ds = Pathfinder.simpleDistance(x, y, vsUnit.x, vsUnit.y);

        positionWeight += (vsUnit.aiRelativeWeight / ds);
        if (positionWeight > 10000) {
          console.log('infinity?');
        }

        if (ds === 1) {
          vsUnitType = vsUnit.type;
          if (myBonus || vsUnitType.bless > 0 || vsUnitType.berzerk > 0) {
            positionWeight += unit.aiRelativeWeight;
          }
        }

      }
    }

    unit.x = originalX;
    unit.y = originalY;

    if (DEBUG) {
      var v = "" + positionWeight.toFixed(2);
      if (v.indexOf('fini') >= 0) {
        console.log('infinity?');
      }
      Cursor.setTextAt(x, y, v);
    }

    return positionWeight;
  }

  function findBestUnitToBuild(x, y) {

    if (DEBUG) {
      console.log("Determining the best unit to build at " + x + "," + y);
    }

    var bestUnitType = null;

    // Get local handles on the AI's current gold as well as
    // the amount they appear to be earning per turn.
    var gold = currentAi.gold;
    if (gold > 0) {

      var income = currentAi.lastIncome;

      var bestScore = 0;

      var totalEnemyUnits = enemyUnits.length;
      var enemy;

      var allTypes = UnitType.all;
      var unitType;

      var relativeScore;
      var score;
      var ds;
      var dsGold;

      for (var i = allTypes.length - 1; i >= 0; --i) {
        unitType = allTypes[i];

        if (unitType.cost > 0) {

          score = AI.evaluateUnitType(unitType);
          relativeScore = 0;

          for (var e = 0; e < totalEnemyUnits; ++e) {
            enemy = enemyUnits[e];
            ds = Pathfinder.manhattanDistance(x, y, enemy.x, enemy.y);
            relativeScore += (score - enemy.aiActualWeight) / ds;
          }

          // If we can afford this unit there is no income "distance"
          // to this unit.  Otherwise, determine the number of turns
          // it will take to acquire enough gold to build the unit.
          if (unitType.cost > gold) {
            if (income <= 0) {
              relativeScore = 0;

            } else {

              dsGold = (unitType.cost - gold) / income;
              if (dsGold < 1) {
                dsGold = 1;
              }
//              dsGold *= currentBias.buildUrgency;

              relativeScore /= dsGold;

              if (DEBUG) {
                console.log(" - " + UnitType.toString(unitType) + " (" + relativeScore.toFixed(3) + ")");
              }

            }
          }

          if (bestUnitType === null || relativeScore > bestScore) {
            bestScore = relativeScore;
            bestUnitType = unitType;

          } else if (relativeScore === bestScore) {
            if (unitType.cost < bestUnitType.cost || (unitType.cost === bestUnitType.cost && coinToss())) {
              bestUnitType = unitType;
            }
          }

        }

      }

      // If the unit costs more than the AI currently has
      // then we can't build it at this time.
      if (bestUnitType.cost > gold) {
        if (DEBUG) {
          console.log("AI can't afford to build " + UnitType.toString(bestUnitType) + " yet");
        }
        bestUnitType = null;
      }

    }

    if (DEBUG) {
      if (bestUnitType === null) {
        console.log(AI.toString(currentAi) + " can not build anything right now");
      } else {
        console.log(AI.toString(currentAi) + " should build " + UnitType.toString(bestUnitType));
      }
    }

    return bestUnitType;
  }

  // Given the provided unit, evaluates the terrain and other
  // units around the target to find the best spot to attack
  // from - e.g. offering the highest defense.
  function findBestAttackPosition(unit, target) {

    if (DEBUG) {
      console.log(" - findBestAttackPosition(" + Unit.toString(unit) + ", " + Unit.toString(target) + ")");
    }

    // Ensure the pathfinder is reset otherwise nodes (with invalid state)
    // from previous AI passes may leak into this pass.
    Pathfinder.reset();

    // Clear
    if (DEBUG) {
      Cursor.reset();
    }

    // This will hold the best possible position the
    // specified unit can move to.
    var bestNode = null;

    var unitType = unit.type;
    var rangeMax = unitType.rangeMax;

    var originalX = unit.x;
    var originalY = unit.y;

    var targetX = target.x;
    var targetY = target.y;

    var minX = targetX - rangeMax;
    var minY = targetY - rangeMax;
    var maxX = targetX + rangeMax;
    var maxY = targetY + rangeMax;

    var node;
    var path;

    for (var y = minY; y <= maxY; ++y) {
      for (var x = minX; x <= maxX; ++x) {

        node = Pathfinder.nodeAt(x, y);
        if (node && node.unit === null && Terrain.isPassable(node.terrain, unitType)) {

          unit.x = x;
          unit.y = y;

          if (Unit.isUnitInAttackRange(unit, target)) {

            node.aiWeight = evaluatePosition(unit, x, y);

            tacticalNodes.push(node);

          }

        }

      }
    }

    // Move the unit back to it's original position.
    unit.x = originalX;
    unit.y = originalY;

    tacticalNodes.sort(nodeSorter);

    var totalTacticalNodes = tacticalNodes.length;
    for (var i = 0; i < totalTacticalNodes; ++i) {
      node = tacticalNodes[i];

      // If the unit's current spot is the best location for the
      // unit, then no path resolution is necessary.
      if (node.x === originalX && node.y === originalY) {
        bestNode = node;

      } else {

        // Resolve a path to an attack position for this unit.
        path = Pathfinder.routeFor(unit, node.x, node.y);
        if (path) {

          bestNode = path.last();
          break;

        }

      }
    }

    tacticalNodes.length = 0;

    return bestNode;
  }

  function clearQueues() {

    currentTask = null;
    currentMode = null;

    // Clear the unit buckets.
    friendlyUnits.length = 0;
    readyUnits.length    = 0;
    enemyUnits.length    = 0;

    if (USE_TASK_QUEUE) {
      taskQueue.length = 0;
    }

    var allTasks = taskPool.active;
    for (var i = allTasks.length - 1; i >= 0; --i) {
      deallocateTask(allTasks[i]);
    }

  }


  //
  // Iterative AI thinking modes follow ...
  //

  function organizeUnits() {

    var allUnits = Unit.all;
    if (currentIndex < allUnits.length) {

      var unit = allUnits[currentIndex++];
      if (!unit.dead) {

        unit.aiActualWeight   = AI.evaluateUnit(unit);
        unit.aiRelativeWeight = 0;

        if (unit.player === currentAi) {
          friendlyUnits.push(unit);

          if (unit.mode === MODE_READY) {
            readyUnits.push(unit);
          }

        } else {
          enemyUnits.push(unit);
        }

      }

    } else {
      nextMode();

    }

  }

  function preprocessUnit(unit, vsUnit, ds) {

    var unitType = unit.type;
    var rangeMin = unitType.rangeMin;
    var rangeMax = unitType.rangeMax;

    if (ds < rangeMin) {
      ds = rangeMin - ds;

    } else {
      ds -= rangeMax;
      if (ds < 1) {
        ds = 1;
      }
    }

    // Calculate how much stronger (or weaker) the first unit is
    // against the second unit.
    var weightAdvantage = unit.aiActualWeight - vsUnit.aiActualWeight;

    // Adjust the unit's relative weight based on it's advantage
    // and distance from the target.
    unit.aiRelativeWeight += (weightAdvantage / ds);

  }

  function preprocessUnits() {

    var friendlyUnit;
    var enemyUnit;
    var ds;

    for (var f = friendlyUnits.length - 1; f >= 0; --f) {
      friendlyUnit = friendlyUnits[f];

      for (var e = enemyUnits.length - 1; e >= 0; --e) {
        enemyUnit = enemyUnits[e];

        ds = Pathfinder.simpleDistance(friendlyUnit.x, friendlyUnit.y, enemyUnit.x, enemyUnit.y);

        preprocessUnit(friendlyUnit, enemyUnit, ds);
        preprocessUnit(enemyUnit, friendlyUnit, ds);

      }

    }

    var minWeight = null;
    var maxWeight = null;
    var weight;
    var unit;

    // Iterate through all of the units and determine the maximum
    // and minimum weights so that we can normalize the relative
    // weights of all units.
    var allUnits = Unit.all;
    for (var i = allUnits.length - 1; i >= 0; --i) {
      unit = allUnits[i];

      weight = unit.aiRelativeWeight;
      if (minWeight === null || weight < minWeight) {
        minWeight = weight;
      }

      if (maxWeight === null || weight > maxWeight) {
        maxWeight = weight;
      }
    }

    maxWeight -= minWeight;

    if (DEBUG) {
      console.log("Normalized AI relative weights:");
    }

    // Normalize all of the unit weights.
    for (i = allUnits.length - 1; i >= 0; --i) {
      unit = allUnits[i];
      unit.aiRelativeWeight = (unit.aiRelativeWeight - minWeight) / maxWeight;

      if (DEBUG) {
        console.log(" - " + Unit.toString(unit) + " " + unit.aiActualWeight + " (" + unit.aiRelativeWeight.toFixed(3) + ")");
      }
    }

    nextMode();

  }

  function evaluateGraves() {

    var allGraves = Grave.all;
    if (currentIndex < allGraves.length) {

      var grave = allGraves[currentIndex++];

      var unit;
      var unitType;
      var x;
      var y;
      var path;
      var node;
      var inRange;

      // Iterate over the list of friendly units and if any are
      // capable of raising undead units, then consider each of
      // the graves on the map.
      var totalAllies = readyUnits.length;
      for (var f = 0; f < totalAllies; ++f) {
        unit = readyUnits[f];
        unitType = unit.type;
        if (unitType.raise) {

          // Can't raise when there is already a unit standing
          // over the grave.
          if (Unit.at(grave.x, grave.y) === null) {

            if (Pathfinder.simpleDistance(unit.x, unit.y, grave.x, grave.y) <= RAISE_RANGE) {
              x = unit.x;
              y = unit.y;
              inRange = true;

            } else {

              path = Pathfinder.routeFor(unit, grave.x, grave.y, 1, RAISE_RANGE);
              if (!path) {
                continue;

              } else {
                node = path.last();
                x = node.x;
                y = node.y;

                inRange = (node.weight <= unitType.movement);

              }

            }

            allocateTask(TASK_RAISE, unit, currentBias.necromancy + grave.attack, x, y, grave, inRange);

          }

        }

      }

    } else {
      nextMode();

    }

  }

  function evaluateStrengths() {

    var totalFriendlyUnits = friendlyUnits.length;
    var totalFriendlyStrength = 0;

    var totalEnemyUnits = enemyUnits.length;
    var totalEnemyStrength = 0;

    // Compare the AI's friendly units against each of the enemy units.
    // For each unit, compare it's strength vs. each other and scale it
    // for distance.  (A unit further away is less of a threat).
    for (var i = 0; i < totalFriendlyUnits; ++i) {
      totalFriendlyStrength += friendlyUnits[i].aiActualWeight;
    }

    for (i = 0; i < totalEnemyUnits; ++i) {
      totalEnemyStrength += enemyUnits[i].aiActualWeight;
    }

    currentBias.buildUrgency = totalEnemyStrength / totalFriendlyStrength;

    // No cycling necessary - just immediately advance to the
    // next AI mode.
    nextMode();

  }

  function evaluateTerrain() {

    if (currentIndex < Map.height()) {

      // For coding convenience.
      var y = currentIndex;

      var totalReadyUnits = readyUnits.length;

      var width = Map.width();
      var terrain;
      var taskType;
      var unit;
      var unitType;
      var modifier;
      var i;

      var unitAtLocation;
      var unitPresent;

      for (var x = 0; x < width; ++x) {
        terrain = Map.terrainAt(x, y);

        // Check to see if there is currently a unit at the
        // specified location.
        unitAtLocation = Unit.at(x, y);
        unitPresent = unitAtLocation !== null;

        if (terrain.player === currentAi) {

          // If the terrain is capable of healing units, iterate through the
          // list of ready but injured units to attempt to heal here.
          if (terrain.heal > 0 && !unitPresent) {
            for (i = 0; i < totalReadyUnits; ++i) {
              unit = readyUnits[i];
              unitType = unit.type;

              if (unit.hitpoints < unitType.hitpoints) {
                modifier = currentBias.healModifier * ((unitType.hitpoints - unit.hitpoints) / unitType.hitpoints);
                allocateTask(TASK_HEAL, unit, modifier, x, y, terrain);
              }

            }
          }

          if (terrain.factory && !unitPresent) {

            modifier = enemyUnits.length - friendlyUnits.length;
            if (modifier < 1) {
              modifier = 1;
            }
            modifier = modifier * currentBias.buildUrgency;

            unit = findBestUnitToBuild(x, y);
            if (unit) {
              allocateTask(TASK_BUILD, null, modifier, x, y, unit);
            }

          }

        } else {

          if (terrain.capture) {

            modifier = currentBias.captureModifier;
            if (terrain.factory) {
              modifier += currentBias.factoryModifier;
            }
            if (terrain.player && terrain.player !== currentAi) {
              modifier += currentBias.takeoverModifier;
            }
            if (currentBias.buildUrgency > 1) {
              modifier *= currentBias.buildUrgency;
            }

            for (i = 0; i < totalReadyUnits; ++i) {
              unit = readyUnits[i];

              if (Terrain.isCaptureable(terrain, unit)) {
                allocateTask(TASK_CAPTURE, unit, modifier, x, y, terrain);
              }

            }

          }

          if (terrain.repair) {

            for (i = 0; i < totalReadyUnits; ++i) {
              unit = readyUnits[i];

              modifier = currentBias.repairModifier;
              if (currentBias.buildUrgency > 1) {
                modifier *= currentBias.buildUrgency;
              }

              if (Terrain.isRepairable(terrain, unit)) {
                allocateTask(TASK_CAPTURE, unit, modifier, x, y, terrain);
              }

            }

          }

        }

      }

      currentIndex++;

    } else {
      nextMode();

    }

  }

  function evaluateUnits() {

    if (currentIndex < readyUnits.length) {

      var friendlyUnit   = readyUnits[currentIndex++];
      var friendlyWeight = friendlyUnit.aiActualWeight;
      var friendlyType   = friendlyUnit.type;

      var enemyUnit;
      var modifier;
      var inRange;
      var x;
      var y;
      var path;
      var node;

      // Iterate through the list of enemy units and create tasks to
      // kill each one.
      var totalEnemies = enemyUnits.length;
      for (var i = 0; i < totalEnemies; ++i) {
        enemyUnit   = enemyUnits[i];

        modifier = currentBias.aggression;

        // Adjust the score based on the AI's bias toward units
        // that may be overpowered.
        modifier += (currentBias.equalityModifier * ((friendlyWeight - enemyUnit.aiActualWeight) / friendlyWeight));

        // Check to see if the friendly unit is already in range of
        // the enemy unit.  If not, check to see if we can move into
        // position within the next turn.
        inRange = Unit.isUnitInAttackRange(friendlyUnit, enemyUnit);
        if (inRange && friendlyType.attackBeforeMove) {
          x = friendlyUnit.x;
          y = friendlyUnit.y;

        } else {

          // Determine what the best attacking point for this unit
          // should be.
          node = findBestAttackPosition(friendlyUnit, enemyUnit);
          if (node === null) {
            continue;
          }

          x    = node.x;
          y    = node.y;

          // If the friendly unit moves before attacking and the last
          // position of the path is within their movement range then
          // we consider the unit as in-range.
          inRange = (!friendlyType.attackBeforeMove && node.weight <= friendlyType.movement);

        }

        // Check to see if the friendly unit is already in a position
        // to attack the enemy without moving.
        if (inRange) {

          modifier += currentBias.inRangeBias;

          if (Unit.calculateDamage(friendlyUnit, enemyUnit, false) >= enemyUnit.hitpoints) {
            modifier += currentBias.instantKillBias;
          }

        }

        allocateTask(TASK_KILL, friendlyUnit, modifier, x, y, enemyUnit, inRange);

      }

    } else {
      nextMode();

    }

  }

  function sortTaskQueue() {

    if (USE_TASK_QUEUE) {
      if (taskQueue.length > 0) {

        taskQueue.sort(taskSorter);

        if (DEBUG) {
          console.log("Resolved AI tasks are:");

          for (var i = 0; i < taskQueue.length; ++i) {
            console.log(" - " + taskToString(taskQueue[i]));
          }
        }

        // Choose the task at the top of the queue which has the
        // highest priority.
        currentTask = taskQueue[0];

      }
    }

    // Check to see if there are tasks in the current queue.
    // If not, then this AI's turn has concluded.
    if (currentTask === null) {
      Player.endTurn();

    } else {

      if (DEBUG) {
        console.log(AI.toString(currentAi) + " active task is " + taskToString(currentTask));
      }

      // If the task involves a unit, then select that unit.  The
      // BUILD task, for example, doesn't involve a selected unit.
      if (currentTask.unit) {
        Unit.select(currentTask.unit);
      }

      nextMode();

    }

  }


  //
  // Functions used during task execution for a specific unit.
  //

  function processAttack() {

    var unit = Cursor.unit;

    // If we've already picked a target, attack that target.
    if (nextTarget) {

      Cursor.clearOverlay();
      Unit.attack(unit, nextTarget, clearNextTarget);

    } else if (currentTask.type !== TASK_KILL) {
      Unit.nextMode(unit);

    } else {

      var enemy = currentTask.target;

      // Check to see if the targeted enemy is within range.  If
      // so, proceed with the attack.  Otherwise, assume the unit
      // will need to move into a better position.
      var enemyNode = Pathfinder.possibleNodeAt(enemy.x, enemy.y);
      if (enemyNode) {

        nextTarget = enemy;

        Cursor.target(nextTarget.x, nextTarget.y, MODE_ATTACK);

      } else {
        if (DEBUG) {
          console.log(Unit.toString(unit) + " is not within attack range of " + Unit.toString(enemy));
        }

        Unit.nextMode(unit);
      }

    }
  }

  function processBuild() {

    Unit.build(currentAi, currentTask.target, currentTask.x, currentTask.y);

  }

  function processCapture() {

    var unit = Cursor.unit;
    if (currentTask.type === TASK_CAPTURE) {
      Unit.capture(unit);
    } else {
      Unit.nextMode(unit);
    }

  }

  function processMove() {

    var unit = Cursor.unit;

    if (nextTarget) {

      if (nextTarget.x === unit.x && nextTarget.y === unit.y) {
        clearNextTarget();

        Unit.nextMode(unit);

      } else if (Cursor.targetAt(nextTarget.x, nextTarget.y)) {
        Unit.walk(unit, nextTarget.x, nextTarget.y, true, clearNextTarget);

      } else {

        // Target the intended move position.
        Cursor.target(nextTarget.x, nextTarget.y, MODE_MOVE);

      }

    } else if (currentTask.x === unit.x && currentTask.y === unit.y) {
      Unit.nextMode(unit);

    } else if (Pathfinder.possibleNodes.length === 0) {
      Unit.nextMode(unit);

    } else {

      // Check to see if we can reach the intended destination.  If so,
      // we'll move directly there during this turn.
      nextTarget = Pathfinder.possibleNodeAt(currentTask.x, currentTask.y);
      if (nextTarget === null) {

        // Otherwise, resolve a path from the unit's current location to the
        // destination.  If a path is returned, iterate along the path until
        // we find the further spot the unit can move.
        var path = Pathfinder.routeFor(unit, currentTask.x, currentTask.y);
        if (path) {

          var node;
          for (var i = path.length - 1; i > 0; --i) {
            node = path[i];

            // If this spot on the path is within the unit's movement
            // range choose it as the next target.
            nextTarget = Pathfinder.possibleNodeAt(node.x, node.y);
            if (nextTarget) {
              break;
            }

          }

        }

      }

      if (nextTarget) {
        if (DEBUG) {
          console.log(Unit.toString(unit) + " is moving from " + unit.x + "," + unit.y + " to " + nextTarget.x + "," + nextTarget.y);
        }

        if (MOVE_CURSOR) {
          Cursor.target(nextTarget.x, nextTarget.y, MODE_MOVE);
        }

      } else {
        if (DEBUG) {
          console.log(Unit.toString(unit) + " has no route to " + taskToString(currentTask));
        }
        Unit.nextMode(unit);

      }

    }

  }

  function processRaise() {

    var unit = Cursor.unit;

    if (nextTarget) {
      Unit.raise(unit, nextTarget, clearNextTarget);

    } else if (currentTask.type !== TASK_RAISE || Pathfinder.possibleNodes.length === 0) {
      Unit.nextMode(unit);

    } else {
      nextTarget = Pathfinder.possibleNodes.random();

      if (MOVE_CURSOR) {
        Cursor.moveTo(nextTarget.x, nextTarget.y);
      }

    }

  }

  function processRepair() {

    var unit = Cursor.unit;
    if (currentTask.type === TASK_CAPTURE) {
      Unit.repair(unit);
    } else {
      Unit.nextMode(unit);
    }

  }

  function processTask() {

    var done = false;

    if (currentTask.type === TASK_BUILD) {
      processBuild();

      done = true;

    } else {

      var unit = Cursor.unit;
      if (unit.mode === MODE_ATTACK) {
        processAttack();
      } else if (unit.mode === MODE_CAPTURE) {
        processCapture();
      } else if (unit.mode === MODE_MOVE) {
        processMove();
      } else if (unit.mode === MODE_RAISE) {
        processRaise();
      } else if (unit.mode === MODE_REPAIR) {
        processRepair();
      } else {
        Unit.nextMode(unit);
      }

      if (unit.dead || unit.mode === MODE_DONE)  {

        // Deselect the unit.
        Cursor.reset();

        done = true;

      }

    }

    if (done) {

      // Now that we've run out of things to do with the
      // current unit, reset the mode and begin thinking
      // through the next move.
      resetMode();

    }

  }

  function setMode(modeIndex) {

    currentMode   = ALL_MODES[modeIndex];
    currentIndex  = 0;
    totalDelta    = 0;

    if (DEBUG) {
      console.log(AI.toString(currentAi) + " entered " + currentMode + " mode.");
    }

  }

  function resetMode() {

    clearQueues();

    setMode(0);

  }

  function nextMode() {
    setMode(ALL_MODES.indexOf(currentMode) + 1);
  }

  return {

    cycle: function(delta) {

      // Task processing occurs at a slower pace in order
      // to ensure that the game progresses at a reasonable pace.
      if (currentMode === MODE_PROCESS_TASKS) {

        totalDelta += delta;
        if (totalDelta >= AI_INTERVAL) {
          totalDelta = 0;
          processTask();
        }

      } else {

        if (currentMode === MODE_EVALUATE_GRAVES) {
          evaluateGraves();
        } else if (currentMode === MODE_EVALUATE_STRENGTHS) {
          evaluateStrengths();
        } else if (currentMode === MODE_EVALUATE_TERRAIN) {
          evaluateTerrain();
        } else if (currentMode === MODE_EVALUATE_UNITS) {
          evaluateUnits();
        } else if (currentMode === MODE_ORGANIZE_UNITS) {
          organizeUnits();
        } else if (currentMode === MODE_PREPROCESS_UNITS) {
          preprocessUnits();
        } else if (currentMode === MODE_SORT_TASKS) {
          sortTaskQueue();
        } else {
          throw "Unknown AI mode " + currentMode;
        }

      }

    },

    evaluateUnit: function(unit) {

      // Calculate the bonus for the unit's earned experience.
      var attack = unit.attack * currentBias.attackMultiplier;
      var defense = unit.defense * currentBias.defenseMultiplier;

      // Calculate the total weight of the unit and it's type.
      var unitType = unit.type;
      var weight   = AI.evaluateUnitType(unitType) + attack + defense;

      // Calculate how damaged the unit is.
      var damagePercent = unit.hitpoints / unitType.hitpoints;

      return weight * damagePercent;
    },

    evaluateUnitType: function(unitType) {
      var attack   = unitType.attack + unitType.attackBonus + unitType.berzerk + unitType.explosive;
      var defense  = unitType.defense + unitType.bless;
      return (attack * currentBias.attackMultiplier) + (defense * currentBias.defenseMultiplier);
    },

    endTurn: function() {

      if (currentAi) {
        if (DEBUG) {
          console.log(AI.toString(currentAi) + " is going to sleep");
        }

        clearQueues();

        currentAi   = null;
        currentBias = null;
        currentMode = null;

      }

    },

    startTurn: function(player) {

      currentAi    = player;
      currentBias  = player.bias;

      if (DEBUG) {
        console.log(AI.toString(currentAi) + " is now active", currentBias);
      }

      resetMode();

    },

    toString: function(ai) {
      return "AI@" + ai.id;
    }

  };
})();
